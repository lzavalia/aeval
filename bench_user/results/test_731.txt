
The Knowledge Scheme currently contains the following lemmas:
	(forall (INT INT) ((plus _qv_0 _qv_1)=(plus _qv_1 _qv_0)))
	(forall (INT INT INT) ((plus (plus _qv_2 _qv_3) _qv_4)=(plus _qv_2 (plus _qv_3 _qv_4))))
	(forall (INT (Lst) (Lst)) ((take _qv_5 (drop _qv_6 _qv_7))=(drop (take _qv_5 _qv_6) (take _qv_5 _qv_7))))
	(forall (INT (Lst) (Lst)) ((drop _qv_8 (take _qv_9 _qv_10))=(take (drop _qv_8 _qv_9) (drop _qv_8 _qv_10))))

Simplified goal: (forall (INT INT (Lst)) (((n>=0)&&(m>=0))->((take n (drop m xs))=(drop m (take (plus n m) xs)))))


Base case:       ((take _v_11 (drop _v_12 nil))=(drop _v_12 (take (plus _v_11 _v_12) nil)))
{
  proven trivially
}
Inductive step:  ((take _v_11 (drop _v_12 (cons _t_13 _t_14)))=(drop _v_12 (take (plus _v_11 _v_12) (cons _t_13 _t_14))))
{
  {
    ====================
    | Assumptions [0]: (forall (INT) ((_qv_1>=0)->((plus 0 _qv_1)=_qv_1)))
    | Assumptions [1]: (forall (INT INT) (((_qv_2>=0)&&(_qv_3>=0))->((plus 1+_qv_2 _qv_3)=(1+(plus _qv_2 _qv_3)))))
    | Assumptions [2]: (forall (INT INT) (((_qv_4>=0)&&(_qv_5>=0))->((plus _qv_4 _qv_5)=(_qv_4+_qv_5))))
    | Assumptions [3]: (forall (INT) ((drop _qv_6 nil)=nil))
    | Assumptions [4]: (forall ((Lst)) ((drop 0 _qv_7)=_qv_7))
    | Assumptions [5]: (forall (INT INT (Lst)) ((_qv_8>=0)->((drop _qv_8+1 (cons _qv_9 _qv_10))=(drop _qv_8 _qv_10))))
    | Assumptions [6]: (forall (INT) ((take _qv_11 nil)=nil))
    | Assumptions [7]: (forall ((Lst)) ((take 0 _qv_12)=nil))
    | Assumptions [8]: (forall (INT INT (Lst)) ((_qv_13>=0)->((take _qv_13+1 (cons _qv_14 _qv_15))=(cons _qv_14 (take _qv_13 _qv_15)))))
    | Assumptions [9]: (_v_11>=0)
    | Assumptions [10]: (_v_12>=0)
    | Assumptions [11]: (forall (INT INT) (((n>=0)&&(m>=0))->((take n (drop m _t_14))=(drop m (take (plus n m) _t_14)))))
    | Assumptions [12]: ((plus 0 _v_11)=_v_11)
    | Assumptions [13]: ((plus _v_11+1 _v_12)=((plus _v_11 _v_12)+1))
    | Assumptions [14]: ((plus _v_11 _v_12)=(_v_11+_v_12))
    | Assumptions [15]: (forall (INT (Lst)) ((drop _v_11+1 (cons _qv_9 _qv_10))=(drop _v_11 _qv_10)))
    | Assumptions [16]: (forall (INT (Lst)) ((take _v_11+1 (cons _qv_14 _qv_15))=(cons _qv_14 (take _v_11 _qv_15))))
    | Assumptions [17]: ((take _v_11 (drop _v_12 _t_14))=(drop _v_12 (take (plus _v_11 _v_12) _t_14)))
    | Assumptions [18]: ((plus _v_11+1 _v_12)=[+    _v_11    _v_12    1])
    | Assumptions [19]: ((take _v_11 (drop _v_12 _t_14))=(drop _v_12 (take _v_11+_v_12 _t_14)))
    | Assumptions [20]: ((_v_11+_v_12)=(plus _v_11 _v_12))
    | Assumptions [21]: ((drop _v_12 (take _v_11+_v_12 _t_14))=(drop _v_12 (take (plus _v_11 _v_12) _t_14)))
    | Assumptions [22]: ((drop _v_12 (take (plus _v_11 _v_12) _t_14))=(drop _v_12 (take _v_11+_v_12 _t_14)))
    ====================
  }
  rewritten [14]: ((take _v_11 (drop _v_12 (cons _t_13 _t_14)))=(drop _v_12 (take _v_11+_v_12 (cons _t_13 _t_14))))
  rewritten [20]: ((take _v_11 (drop _v_12 (cons _t_13 _t_14)))=(drop _v_12 (take (plus _v_11 _v_12) (cons _t_13 _t_14))))

The Knowledge Scheme currently contains the following lemmas:
	(forall (INT INT) ((plus _qv_16 _qv_17)=(plus _qv_17 _qv_16)))
	(forall (INT INT INT) ((plus (plus _qv_18 _qv_19) _qv_20)=(plus _qv_18 (plus _qv_19 _qv_20))))
	(forall (INT (Lst) (Lst)) ((take _qv_21 (drop _qv_22 _qv_23))=(drop (take _qv_21 _qv_22) (take _qv_21 _qv_23))))
	(forall (INT (Lst) (Lst)) ((drop _qv_24 (take _qv_25 _qv_26))=(take (drop _qv_24 _qv_25) (drop _qv_24 _qv_26))))


The Knowledge Scheme currently contains the following lemmas:
	(forall (INT INT) ((plus _qv_30 _qv_31)=(plus _qv_31 _qv_30)))
	(forall (INT INT INT) ((plus (plus _qv_32 _qv_33) _qv_34)=(plus _qv_32 (plus _qv_33 _qv_34))))
	(forall (INT (Lst) (Lst)) ((take _qv_35 (drop _qv_36 _qv_37))=(drop (take _qv_35 _qv_36) (take _qv_35 _qv_37))))
	(forall (INT (Lst) (Lst)) ((drop _qv_38 (take _qv_39 _qv_40))=(take (drop _qv_38 _qv_39) (drop _qv_38 _qv_40))))

