
The Knowledge Scheme currently contains the following lemmas:
	(forall ((Lst) (Lst)) ((append _qv_0 _qv_1)=(append _qv_1 _qv_0)))
	(forall ((Lst) (Lst) (Lst)) ((append (append _qv_2 _qv_3) _qv_4)=(append _qv_2 (append _qv_3 _qv_4))))
	(forall ((Lst)) ((butlast (butlast _qv_5))=_qv_5))
	(forall ((Lst) (Lst)) ((butlast (append _qv_6 _qv_7))=(append (butlast _qv_6) (butlast _qv_7))))
	(forall ((Lst) (Lst)) ((butlast (append _qv_6 _qv_7))=(append (butlast _qv_7) (butlast _qv_6))))

Simplified goal: (forall ((Lst) (Lst)) (((ys=nil)&&((butlast (append xs ys))=(butlast xs)))||(((butlast (append xs ys))=(append xs (butlast ys)))&&(ys!=nil))))


Base case:       (((_v_8=nil)&&((butlast (append nil _v_8))=(butlast nil)))||(((butlast (append nil _v_8))=(append nil (butlast _v_8)))&&(_v_8!=nil)))
{
  proven trivially
}
Inductive step:  (((_v_8=nil)&&((butlast (append (cons _t_9 _t_10) _v_8))=(butlast (cons _t_9 _t_10))))||(((butlast (append (cons _t_9 _t_10) _v_8))=(append (cons _t_9 _t_10) (butlast _v_8)))&&(_v_8!=nil)))
{
  {
    ====================
    | Assumptions [0]: ((butlast nil)=nil)
    | Assumptions [1]: (forall ((Lst)) ((append nil _qv_1)=_qv_1))
    | Assumptions [2]: (forall (INT (Lst) (Lst)) ((append (cons _qv_2 _qv_3) _qv_4)=(cons _qv_2 (append _qv_3 _qv_4))))
    | Assumptions [3]: (forall (INT (Lst)) ((last (cons _qv_5 _qv_6))=ite(_qv_6=nil, _qv_5, (last _qv_6))))
    | Assumptions [4]: (forall (INT (Lst)) ((butlast (cons _qv_7 _qv_8))=ite(_qv_8=nil, nil, (cons _qv_7 (butlast _qv_8)))))
    | Assumptions [5]: (forall ((Lst)) (((ys=nil)&&((butlast (append _t_10 ys))=(butlast _t_10)))||((ys!=nil)&&((butlast (append _t_10 ys))=(append _t_10 (butlast ys))))))
    ====================
  }
  rewritten [2]: (((_v_8=nil)&&((butlast (cons _t_9 (append _t_10 _v_8)))=(butlast (cons _t_9 _t_10))))||((_v_8!=nil)&&((butlast (cons _t_9 (append _t_10 _v_8)))=(append (cons _t_9 _t_10) (butlast _v_8)))))
  rewritten [2]: (((_v_8=nil)&&((butlast (cons _t_9 (append _t_10 _v_8)))=(butlast (cons _t_9 _t_10))))||((_v_8!=nil)&&((butlast (cons _t_9 (append _t_10 _v_8)))=(cons _t_9 (append _t_10 (butlast _v_8))))))
  rewritten [4]: (((_v_8=nil)&&((butlast (cons _t_9 (append _t_10 _v_8)))=ite(_t_10=nil, nil, (cons _t_9 (butlast _t_10)))))||((_v_8!=nil)&&((butlast (cons _t_9 (append _t_10 _v_8)))=(cons _t_9 (append _t_10 (butlast _v_8))))))
  rewritten [4]: (((_v_8!=nil)&&(ite((append _t_10 _v_8)=nil, nil, (cons _t_9 (butlast (append _t_10 _v_8))))=(cons _t_9 (append _t_10 (butlast _v_8)))))||((_v_8=nil)&&ite(_t_10=nil, ite((append _t_10 _v_8)=nil, nil, (cons _t_9 (butlast (append _t_10 _v_8))))=nil, ite((append _t_10 _v_8)=nil, nil, (cons _t_9 (butlast (append _t_10 _v_8))))=(cons _t_9 (butlast _t_10)))))
  sequence of rewrites only grows

The Knowledge Scheme currently contains the following lemmas:
	(forall ((Lst) (Lst)) ((append _qv_15 _qv_16)=(append _qv_16 _qv_15)))
	(forall ((Lst) (Lst) (Lst)) ((append (append _qv_17 _qv_18) _qv_19)=(append _qv_17 (append _qv_18 _qv_19))))
	(forall ((Lst)) ((butlast (butlast _qv_20))=_qv_20))
	(forall ((Lst) (Lst)) ((butlast (append _qv_21 _qv_22))=(append (butlast _qv_21) (butlast _qv_22))))
	(forall ((Lst) (Lst)) ((butlast (append _qv_21 _qv_22))=(append (butlast _qv_22) (butlast _qv_21))))


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Lst) (Lst)) ((append _qv_25 _qv_26)=(append _qv_26 _qv_25)))
	(forall ((Lst) (Lst) (Lst)) ((append (append _qv_27 _qv_28) _qv_29)=(append _qv_27 (append _qv_28 _qv_29))))
	(forall ((Lst)) ((butlast (butlast _qv_30))=_qv_30))
	(forall ((Lst) (Lst)) ((butlast (append _qv_31 _qv_32))=(append (butlast _qv_31) (butlast _qv_32))))
	(forall ((Lst) (Lst)) ((butlast (append _qv_31 _qv_32))=(append (butlast _qv_32) (butlast _qv_31))))

