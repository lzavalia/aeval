
The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat) (Nat)) ((less _qv_0 _qv_1)=(less _qv_1 _qv_0)))
	(forall ((Lst)) ((filter (filter _qv_2))=_qv_2))

Simplified goal: (forall ((Lst)) (((len (filter xs))=(len xs))||(less (len (filter xs)) (len xs))))


Base case:       (((len (filter nil))=(len nil))||(less (len (filter nil)) (len nil)))
{
  proven trivially
}
Inductive step:  (((len (filter (cons _t_3 _t_4)))=(len (cons _t_3 _t_4)))||(less (len (filter (cons _t_3 _t_4))) (len (cons _t_3 _t_4))))
{
  {
    ====================
    | Assumptions [0]: ((filter nil)=nil)
    | Assumptions [1]: (forall ((Nat) (Nat)) ((less (succ _qv_3) (succ _qv_4))=(less _qv_3 _qv_4)))
    | Assumptions [2]: (forall ((Nat) (Lst)) ((len (cons _qv_5 _qv_6))=(succ (len _qv_6))))
    | Assumptions [3]: (forall ((Nat) (Lst)) ((filter (cons _qv_7 _qv_8))=ite((P _qv_7), (cons _qv_7 (filter _qv_8)), (filter _qv_8))))
    | Assumptions [4]: (((len (filter _t_4))=(len _t_4))||(less (len (filter _t_4)) (len _t_4)))
    | Assumptions [5]: (forall ((Nat)) (!(less _qv_1 (len nil))))
    | Assumptions [6]: (forall ((Nat)) (less (len nil) (succ _qv_2)))
    ====================
  }
  rewritten [2]: (((len (filter (cons _t_3 _t_4)))=(succ (len _t_4)))||(less (len (filter (cons _t_3 _t_4))) (succ (len _t_4))))
  rewritten [3]: (((len ite((P _t_3), (cons _t_3 (filter _t_4)), (filter _t_4)))=(succ (len _t_4)))||(less (len ite((P _t_3), (cons _t_3 (filter _t_4)), (filter _t_4))) (succ (len _t_4))))
  rewritten [2]: (ite((P _t_3), (succ (len (filter _t_4)))=(succ (len _t_4)), (len (filter _t_4))=(succ (len _t_4)))||ite((P _t_3), (less (succ (len (filter _t_4))) (succ (len _t_4))), (less (len (filter _t_4)) (succ (len _t_4)))))
  rewritten [1]: (ite((P _t_3), (succ (len (filter _t_4)))=(succ (len _t_4)), (len (filter _t_4))=(succ (len _t_4)))||ite((P _t_3), (less (len (filter _t_4)) (len _t_4)), (less (len (filter _t_4)) (succ (len _t_4)))))
  split for (part 1/2): ((len (filter _t_4))=(len _t_4))
  {
    {
      ====================
      | Assumptions [0]: ((filter nil)=nil)
      | Assumptions [1]: (forall ((Nat) (Nat)) ((less (succ _qv_3) (succ _qv_4))=(less _qv_3 _qv_4)))
      | Assumptions [2]: (forall ((Nat) (Lst)) ((len (cons _qv_5 _qv_6))=(succ (len _qv_6))))
      | Assumptions [3]: (forall ((Nat) (Lst)) ((filter (cons _qv_7 _qv_8))=ite((P _qv_7), (cons _qv_7 (filter _qv_8)), (filter _qv_8))))
      | Assumptions [4]: ((len (filter _t_4))=(len _t_4))
      | Assumptions [5]: (forall ((Nat)) (!(less _qv_1 (len nil))))
      | Assumptions [6]: (forall ((Nat)) (less (len nil) (succ _qv_2)))
      ====================
    }
    rewritten [4]: (ite((P _t_3), (succ (len _t_4))=(succ (len _t_4)), (len _t_4)=(succ (len _t_4)))||ite((P _t_3), (less (len _t_4) (len _t_4)), (less (len _t_4) (succ (len _t_4)))))
    deciding: ite((P _t_3), (less (len _t_4) (len _t_4)), (less (len _t_4) (succ (len _t_4))))
    {
      ====================
      | Assumptions [0]: ((filter nil)=nil)
      | Assumptions [1]: (forall ((Nat) (Nat)) ((less (succ _qv_3) (succ _qv_4))=(less _qv_3 _qv_4)))
      | Assumptions [2]: (forall ((Nat) (Lst)) ((len (cons _qv_5 _qv_6))=(succ (len _qv_6))))
      | Assumptions [3]: (forall ((Nat) (Lst)) ((filter (cons _qv_7 _qv_8))=ite((P _qv_7), (cons _qv_7 (filter _qv_8)), (filter _qv_8))))
      | Assumptions [4]: ((len (filter _t_4))=(len _t_4))
      | Assumptions [5]: (forall ((Nat)) (!(less _qv_1 (len nil))))
      | Assumptions [6]: (forall ((Nat)) (less (len nil) (succ _qv_2)))
      | Assumptions [7]: (!ite((P _t_3), (less (len _t_4) (len _t_4)), (less (len _t_4) (succ (len _t_4)))))
      ====================
    }
    current subgoal: ite((P _t_3), true, (len _t_4)=(succ (len _t_4)))
    {
      proceed with (part 1/2): ((P _t_3)->true)
      {
          proven trivially (with Z3)
      }
      adding ((P _t_3)->true) to assumptions
      proceed with (part 2/2): ((!(P _t_3))->((len _t_4)=(succ (len _t_4))))
      {
        {
          ====================
          | Assumptions [0]: true
          | Assumptions [1]: ((filter nil)=nil)
          | Assumptions [2]: (forall ((Nat) (Nat)) ((less (succ _qv_3) (succ _qv_4))=(less _qv_3 _qv_4)))
          | Assumptions [3]: (forall ((Nat) (Lst)) ((len (cons _qv_5 _qv_6))=(succ (len _qv_6))))
          | Assumptions [4]: (forall ((Nat) (Lst)) ((filter (cons _qv_7 _qv_8))=ite((P _qv_7), (cons _qv_7 (filter _qv_8)), (filter _qv_8))))
          | Assumptions [5]: ((len (filter _t_4))=(len _t_4))
          | Assumptions [6]: (forall ((Nat)) (!(less _qv_1 (len nil))))
          | Assumptions [7]: (forall ((Nat)) (less (len nil) (succ _qv_2)))
          | Assumptions [8]: (!ite((P _t_3), (less (len _t_4) (len _t_4)), (less (len _t_4) (succ (len _t_4)))))
          | Assumptions [9]: (!(P _t_3))
          ====================
        }
        current subgoal: ((len _t_4)=(succ (len _t_4)))
      }
      will try subgoals again
      proceed with (part 1/1): ((!(P _t_3))->((len _t_4)=(succ (len _t_4))))
      {
        {
          ====================
          | Assumptions [0]: true
          | Assumptions [1]: ((filter nil)=nil)
          | Assumptions [2]: (forall ((Nat) (Nat)) ((less (succ _qv_3) (succ _qv_4))=(less _qv_3 _qv_4)))
          | Assumptions [3]: (forall ((Nat) (Lst)) ((len (cons _qv_5 _qv_6))=(succ (len _qv_6))))
          | Assumptions [4]: (forall ((Nat) (Lst)) ((filter (cons _qv_7 _qv_8))=ite((P _qv_7), (cons _qv_7 (filter _qv_8)), (filter _qv_8))))
          | Assumptions [5]: ((len (filter _t_4))=(len _t_4))
          | Assumptions [6]: (forall ((Nat)) (!(less _qv_1 (len nil))))
          | Assumptions [7]: (forall ((Nat)) (less (len nil) (succ _qv_2)))
          | Assumptions [8]: (!ite((P _t_3), (less (len _t_4) (len _t_4)), (less (len _t_4) (succ (len _t_4)))))
          | Assumptions [9]: (!(P _t_3))
          ====================
        }
        current subgoal: ((len _t_4)=(succ (len _t_4)))
      }
      cannot prove 1 of the subgoals
    }

The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat) (Nat)) ((less _qv_6 _qv_7)=(less _qv_7 _qv_6)))
	(forall ((Lst)) ((filter (filter _qv_8))=_qv_8))


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat) (Nat)) ((less _qv_13 _qv_14)=(less _qv_14 _qv_13)))
	(forall ((Lst)) ((filter (filter _qv_15))=_qv_15))

CURRENT SUBGOAL [||    (P _v_9)    (_v_10=(succ _v_10))&&((less _v_10 _v_10)=(less _v_10 (succ _v_10)))    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Nat) (Nat)) ((less _qv_6 _qv_7)=(less _qv_7 _qv_6)))
USE ASSUMPTION FAILED

CURRENT SUBGOAL [||    (P _v_9)    (_v_10=(succ _v_10))&&((less _v_10 _v_10)=(less _v_10 (succ _v_10)))    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Lst)) ((filter (filter _qv_8))=_qv_8))
USE ASSUMPTION FAILED


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat) (Nat)) ((less _qv_18 _qv_19)=(less _qv_19 _qv_18)))
	(forall ((Lst)) ((filter (filter _qv_20))=_qv_20))

CURRENT SUBGOAL [||    (P _v_9)    (_v_10=(succ _v_10))&&((less _v_10 _v_10)=(less _v_10 (succ _v_10)))    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Nat) (Nat)) ((less _qv_6 _qv_7)=(less _qv_7 _qv_6)))
USE ASSUMPTION FAILED

CURRENT SUBGOAL [||    (P _v_9)    (_v_10=(succ _v_10))&&((less _v_10 _v_10)=(less _v_10 (succ _v_10)))    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Lst)) ((filter (filter _qv_8))=_qv_8))
USE ASSUMPTION FAILED


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat) (Nat)) ((less _qv_23 _qv_24)=(less _qv_24 _qv_23)))
	(forall ((Lst)) ((filter (filter _qv_25))=_qv_25))

CURRENT SUBGOAL [||    (_v_10=(succ _v_10))&&((less _v_10 _v_10)=(less _v_10 (succ _v_10)))    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Nat) (Nat)) ((less _qv_6 _qv_7)=(less _qv_7 _qv_6)))
USE ASSUMPTION FAILED

CURRENT SUBGOAL [||    (_v_10=(succ _v_10))&&((less _v_10 _v_10)=(less _v_10 (succ _v_10)))    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Lst)) ((filter (filter _qv_8))=_qv_8))
USE ASSUMPTION FAILED


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat) (Nat)) ((less _qv_28 _qv_29)=(less _qv_29 _qv_28)))
	(forall ((Lst)) ((filter (filter _qv_30))=_qv_30))

CURRENT SUBGOAL [||    (_v_10=(succ _v_10))&&((less _v_10 _v_10)=(less _v_10 (succ _v_10)))    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Nat) (Nat)) ((less _qv_6 _qv_7)=(less _qv_7 _qv_6)))
USE ASSUMPTION FAILED

CURRENT SUBGOAL [||    (_v_10=(succ _v_10))&&((less _v_10 _v_10)=(less _v_10 (succ _v_10)))    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Lst)) ((filter (filter _qv_8))=_qv_8))
USE ASSUMPTION FAILED


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat)) ((succ (succ _qv_33))=_qv_33))
	(forall ((Nat) (Nat)) ((less _qv_34 _qv_35)=(less _qv_35 _qv_34)))
	(forall ((Lst)) ((filter (filter _qv_36))=_qv_36))

CURRENT SUBGOAL [||    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Nat) (Nat)) ((less _qv_6 _qv_7)=(less _qv_7 _qv_6)))
USE ASSUMPTION FAILED

CURRENT SUBGOAL [||    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Lst)) ((filter (filter _qv_8))=_qv_8))
USE ASSUMPTION FAILED


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat)) ((succ (succ _qv_36))=_qv_36))
	(forall ((Nat) (Nat)) ((less _qv_37 _qv_38)=(less _qv_38 _qv_37)))
	(forall ((Lst)) ((filter (filter _qv_39))=_qv_39))

CURRENT SUBGOAL [||    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Nat) (Nat)) ((less _qv_6 _qv_7)=(less _qv_7 _qv_6)))
USE ASSUMPTION FAILED

CURRENT SUBGOAL [||    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Lst)) ((filter (filter _qv_8))=_qv_8))
USE ASSUMPTION FAILED


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat)) ((succ (succ _qv_39))=_qv_39))
	(forall ((Nat) (Nat)) ((less _qv_40 _qv_41)=(less _qv_41 _qv_40)))
	(forall ((Lst)) ((filter (filter _qv_42))=_qv_42))

CURRENT SUBGOAL [||    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Nat) (Nat)) ((less _qv_6 _qv_7)=(less _qv_7 _qv_6)))
USE ASSUMPTION FAILED

CURRENT SUBGOAL [||    (!(P _v_9))&&((len (filter nil))!=(len nil))    (P _v_9)&&((len (filter nil))!=(len nil))    [&&    (filter nil)!=nil    !(P _v_9)    (len (filter nil))!=(len nil)]    (!(P _v_9))&&(less _v_10 (succ _v_10))]
NOW TESTING (forall ((Lst)) ((filter (filter _qv_8))=_qv_8))
USE ASSUMPTION FAILED


The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat)) ((succ (succ _qv_42))=_qv_42))
	(forall ((Nat) (Nat)) ((less _qv_43 _qv_44)=(less _qv_44 _qv_43)))
	(forall ((Lst)) ((filter (filter _qv_45))=_qv_45))

