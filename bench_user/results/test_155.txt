
The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat)) ((succ (succ _qv_0))=_qv_0))
	(forall ((Nat)) (0<=(nat-to-int _qv_1)))
	(forall ((Lst) (Lst)) ((zip _qv_2 _qv_3)=(zip _qv_3 _qv_2)))
	(forall ((Nat)) ((nat-to-int (succ _qv_4))=(nat-to-int _qv_4)))

Simplified goal: (forall ((Nat) (Lst) (Lst)) ((zdrop n (zip xs ys))=(zip (drop n xs) (drop n ys))))


Base case:       ((zdrop zero (zip _v_5 _v_6))=(zip (drop zero _v_5) (drop zero _v_6)))
{
  proven trivially
}
Inductive step:  ((zdrop (succ _t_7) (zip _v_5 _v_6))=(zip (drop (succ _t_7) _v_5) (drop (succ _t_7) _v_6)))
{
  {
    ====================
    | Assumptions [0]: ((nat-to-int zero)=0)
    | Assumptions [1]: (forall ((Nat)) ((nat-to-int _qv_1)>=0))
    | Assumptions [2]: (forall ((Nat) (Nat)) (((nat-to-int _qv_2)=(nat-to-int _qv_3))->(_qv_2=_qv_3)))
    | Assumptions [3]: (forall ((Nat)) ((nat-to-int (succ _qv_4))=(1+(nat-to-int _qv_4))))
    | Assumptions [4]: (forall ((Nat)) ((drop _qv_5 nil)=nil))
    | Assumptions [5]: (forall ((Lst)) ((drop zero _qv_6)=_qv_6))
    | Assumptions [6]: (forall ((Nat) (Nat) (Lst)) ((drop (succ _qv_7) (cons _qv_8 _qv_9))=(drop _qv_7 _qv_9)))
    | Assumptions [7]: (forall ((Lst)) ((zip nil _qv_10)=znil))
    | Assumptions [8]: (forall ((Lst)) ((zip _qv_11 nil)=znil))
    | Assumptions [9]: (forall ((Nat) (Lst) (Nat) (Lst)) ((zip (cons _qv_12 _qv_13) (cons _qv_14 _qv_15))=(zcons (mkpair _qv_12 _qv_14) (zip _qv_13 _qv_15))))
    | Assumptions [10]: (forall ((Nat)) ((zdrop _qv_16 znil)=znil))
    | Assumptions [11]: (forall ((ZLst)) ((zdrop zero _qv_17)=_qv_17))
    | Assumptions [12]: (forall ((Nat) (Pair) (ZLst)) ((zdrop (succ _qv_18) (zcons _qv_19 _qv_20))=(zdrop _qv_18 _qv_20)))
    | Assumptions [13]: (forall ((Lst) (Lst)) ((zdrop _t_7 (zip xs ys))=(zip (drop _t_7 xs) (drop _t_7 ys))))
    | Assumptions [14]: (forall ((Lst) (Lst)) ((zip (drop _t_7 xs) (drop _t_7 ys))=(zdrop _t_7 (zip xs ys))))
    ====================
  }

Base case:       ((zdrop _v_8 (zip nil _v_9))=(zip (drop _v_8 nil) (drop _v_8 _v_9)))
{
  proven trivially
}
Inductive step:  ((zdrop _v_8 (zip (cons _t_10 _t_11) _v_9))=(zip (drop _v_8 (cons _t_10 _t_11)) (drop _v_8 _v_9)))
{
  {
    ====================
    | Assumptions [0]: ((nat-to-int zero)=0)
    | Assumptions [1]: (forall ((Nat)) ((nat-to-int _qv_1)>=0))
    | Assumptions [2]: (forall ((Nat) (Nat)) (((nat-to-int _qv_2)=(nat-to-int _qv_3))->(_qv_2=_qv_3)))
    | Assumptions [3]: (forall ((Nat)) ((nat-to-int (succ _qv_4))=(1+(nat-to-int _qv_4))))
    | Assumptions [4]: (forall ((Nat)) ((drop _qv_5 nil)=nil))
    | Assumptions [5]: (forall ((Lst)) ((drop zero _qv_6)=_qv_6))
    | Assumptions [6]: (forall ((Nat) (Nat) (Lst)) ((drop (succ _qv_7) (cons _qv_8 _qv_9))=(drop _qv_7 _qv_9)))
    | Assumptions [7]: (forall ((Lst)) ((zip nil _qv_10)=znil))
    | Assumptions [8]: (forall ((Lst)) ((zip _qv_11 nil)=znil))
    | Assumptions [9]: (forall ((Nat) (Lst) (Nat) (Lst)) ((zip (cons _qv_12 _qv_13) (cons _qv_14 _qv_15))=(zcons (mkpair _qv_12 _qv_14) (zip _qv_13 _qv_15))))
    | Assumptions [10]: (forall ((Nat)) ((zdrop _qv_16 znil)=znil))
    | Assumptions [11]: (forall ((ZLst)) ((zdrop zero _qv_17)=_qv_17))
    | Assumptions [12]: (forall ((Nat) (Pair) (ZLst)) ((zdrop (succ _qv_18) (zcons _qv_19 _qv_20))=(zdrop _qv_18 _qv_20)))
    | Assumptions [13]: (forall ((Lst) (Lst)) ((zdrop _t_7 (zip xs ys))=(zip (drop _t_7 xs) (drop _t_7 ys))))
    | Assumptions [14]: (forall ((Lst) (Lst)) ((zip (drop _t_7 xs) (drop _t_7 ys))=(zdrop _t_7 (zip xs ys))))
    | Assumptions [15]: (forall ((Nat) (Lst)) ((zdrop n (zip _t_11 ys))=(zip (drop n _t_11) (drop n ys))))
    | Assumptions [16]: (forall ((Nat) (Lst)) ((zip (drop n _t_11) (drop n ys))=(zdrop n (zip _t_11 ys))))
    ====================
  }

Base case:       ((zdrop _v_12 (zip _v_13 nil))=(zip (drop _v_12 _v_13) (drop _v_12 nil)))
{
  proven trivially
}
Inductive step:  ((zdrop _v_12 (zip _v_13 (cons _t_14 _t_15)))=(zip (drop _v_12 _v_13) (drop _v_12 (cons _t_14 _t_15))))
{
  {
    ====================
    | Assumptions [0]: ((nat-to-int zero)=0)
    | Assumptions [1]: (forall ((Nat)) ((nat-to-int _qv_1)>=0))
    | Assumptions [2]: (forall ((Nat) (Nat)) (((nat-to-int _qv_2)=(nat-to-int _qv_3))->(_qv_2=_qv_3)))
    | Assumptions [3]: (forall ((Nat)) ((nat-to-int (succ _qv_4))=(1+(nat-to-int _qv_4))))
    | Assumptions [4]: (forall ((Nat)) ((drop _qv_5 nil)=nil))
    | Assumptions [5]: (forall ((Lst)) ((drop zero _qv_6)=_qv_6))
    | Assumptions [6]: (forall ((Nat) (Nat) (Lst)) ((drop (succ _qv_7) (cons _qv_8 _qv_9))=(drop _qv_7 _qv_9)))
    | Assumptions [7]: (forall ((Lst)) ((zip nil _qv_10)=znil))
    | Assumptions [8]: (forall ((Lst)) ((zip _qv_11 nil)=znil))
    | Assumptions [9]: (forall ((Nat) (Lst) (Nat) (Lst)) ((zip (cons _qv_12 _qv_13) (cons _qv_14 _qv_15))=(zcons (mkpair _qv_12 _qv_14) (zip _qv_13 _qv_15))))
    | Assumptions [10]: (forall ((Nat)) ((zdrop _qv_16 znil)=znil))
    | Assumptions [11]: (forall ((ZLst)) ((zdrop zero _qv_17)=_qv_17))
    | Assumptions [12]: (forall ((Nat) (Pair) (ZLst)) ((zdrop (succ _qv_18) (zcons _qv_19 _qv_20))=(zdrop _qv_18 _qv_20)))
    | Assumptions [13]: (forall ((Lst) (Lst)) ((zdrop _t_7 (zip xs ys))=(zip (drop _t_7 xs) (drop _t_7 ys))))
    | Assumptions [14]: (forall ((Lst) (Lst)) ((zip (drop _t_7 xs) (drop _t_7 ys))=(zdrop _t_7 (zip xs ys))))
    | Assumptions [15]: (forall ((Nat) (Lst)) ((zdrop n (zip _t_11 ys))=(zip (drop n _t_11) (drop n ys))))
    | Assumptions [16]: (forall ((Nat) (Lst)) ((zip (drop n _t_11) (drop n ys))=(zdrop n (zip _t_11 ys))))
    | Assumptions [17]: (forall ((Nat) (Lst)) ((zdrop n (zip xs _t_15))=(zip (drop n xs) (drop n _t_15))))
    | Assumptions [18]: (forall ((Nat) (Lst)) ((zip (drop n xs) (drop n _t_15))=(zdrop n (zip xs _t_15))))
    ====================
  }
Unknown
sat
