
The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat)) ((succ (succ _qv_0))=_qv_0))
	(forall ((Nat)) (0<=(nat-to-int _qv_1)))
	(forall ((Lst) (Lst)) ((zip _qv_2 _qv_3)=(zip _qv_3 _qv_2)))
	(forall ((Nat)) ((nat-to-int (succ _qv_4))=(nat-to-int _qv_4)))

Simplified goal: (forall ((Nat) (Lst) (Lst)) ((ztake n (zip xs ys))=(zip (take n xs) (take n ys))))


Base case:       ((ztake zero (zip _v_5 _v_6))=(zip (take zero _v_5) (take zero _v_6)))
{
  proven trivially
}
Inductive step:  ((ztake (succ _t_7) (zip _v_5 _v_6))=(zip (take (succ _t_7) _v_5) (take (succ _t_7) _v_6)))
{
  {
    ====================
    | Assumptions [0]: ((nat-to-int zero)=0)
    | Assumptions [1]: (forall ((Nat)) ((nat-to-int _qv_1)>=0))
    | Assumptions [2]: (forall ((Nat) (Nat)) (((nat-to-int _qv_2)=(nat-to-int _qv_3))->(_qv_2=_qv_3)))
    | Assumptions [3]: (forall ((Nat)) ((nat-to-int (succ _qv_4))=(1+(nat-to-int _qv_4))))
    | Assumptions [4]: (forall ((Nat)) ((take _qv_5 nil)=nil))
    | Assumptions [5]: (forall ((Lst)) ((take zero _qv_6)=nil))
    | Assumptions [6]: (forall ((Nat) (Nat) (Lst)) ((take (succ _qv_7) (cons _qv_8 _qv_9))=(cons _qv_8 (take _qv_7 _qv_9))))
    | Assumptions [7]: (forall ((Lst)) ((zip nil _qv_10)=znil))
    | Assumptions [8]: (forall ((Lst)) ((zip _qv_11 nil)=znil))
    | Assumptions [9]: (forall ((Nat) (Lst) (Nat) (Lst)) ((zip (cons _qv_12 _qv_13) (cons _qv_14 _qv_15))=(zcons (mkpair _qv_12 _qv_14) (zip _qv_13 _qv_15))))
    | Assumptions [10]: (forall ((Nat)) ((ztake _qv_16 znil)=znil))
    | Assumptions [11]: (forall ((ZLst)) ((ztake zero _qv_17)=znil))
    | Assumptions [12]: (forall ((Nat) (Pair) (ZLst)) ((ztake (succ _qv_18) (zcons _qv_19 _qv_20))=(zcons _qv_19 (ztake _qv_18 _qv_20))))
    | Assumptions [13]: (forall ((Lst) (Lst)) ((ztake _t_7 (zip xs ys))=(zip (take _t_7 xs) (take _t_7 ys))))
    | Assumptions [14]: (forall ((Lst) (Lst)) ((zip (take _t_7 xs) (take _t_7 ys))=(ztake _t_7 (zip xs ys))))
    ====================
  }

Base case:       ((ztake _v_8 (zip nil _v_9))=(zip (take _v_8 nil) (take _v_8 _v_9)))
{
  proven trivially
}
Inductive step:  ((ztake _v_8 (zip (cons _t_10 _t_11) _v_9))=(zip (take _v_8 (cons _t_10 _t_11)) (take _v_8 _v_9)))
{
  {
    ====================
    | Assumptions [0]: ((nat-to-int zero)=0)
    | Assumptions [1]: (forall ((Nat)) ((nat-to-int _qv_1)>=0))
    | Assumptions [2]: (forall ((Nat) (Nat)) (((nat-to-int _qv_2)=(nat-to-int _qv_3))->(_qv_2=_qv_3)))
    | Assumptions [3]: (forall ((Nat)) ((nat-to-int (succ _qv_4))=(1+(nat-to-int _qv_4))))
    | Assumptions [4]: (forall ((Nat)) ((take _qv_5 nil)=nil))
    | Assumptions [5]: (forall ((Lst)) ((take zero _qv_6)=nil))
    | Assumptions [6]: (forall ((Nat) (Nat) (Lst)) ((take (succ _qv_7) (cons _qv_8 _qv_9))=(cons _qv_8 (take _qv_7 _qv_9))))
    | Assumptions [7]: (forall ((Lst)) ((zip nil _qv_10)=znil))
    | Assumptions [8]: (forall ((Lst)) ((zip _qv_11 nil)=znil))
    | Assumptions [9]: (forall ((Nat) (Lst) (Nat) (Lst)) ((zip (cons _qv_12 _qv_13) (cons _qv_14 _qv_15))=(zcons (mkpair _qv_12 _qv_14) (zip _qv_13 _qv_15))))
    | Assumptions [10]: (forall ((Nat)) ((ztake _qv_16 znil)=znil))
    | Assumptions [11]: (forall ((ZLst)) ((ztake zero _qv_17)=znil))
    | Assumptions [12]: (forall ((Nat) (Pair) (ZLst)) ((ztake (succ _qv_18) (zcons _qv_19 _qv_20))=(zcons _qv_19 (ztake _qv_18 _qv_20))))
    | Assumptions [13]: (forall ((Lst) (Lst)) ((ztake _t_7 (zip xs ys))=(zip (take _t_7 xs) (take _t_7 ys))))
    | Assumptions [14]: (forall ((Lst) (Lst)) ((zip (take _t_7 xs) (take _t_7 ys))=(ztake _t_7 (zip xs ys))))
    | Assumptions [15]: (forall ((Nat) (Lst)) ((ztake n (zip _t_11 ys))=(zip (take n _t_11) (take n ys))))
    | Assumptions [16]: (forall ((Nat) (Lst)) ((zip (take n _t_11) (take n ys))=(ztake n (zip _t_11 ys))))
    ====================
  }

Base case:       ((ztake _v_12 (zip _v_13 nil))=(zip (take _v_12 _v_13) (take _v_12 nil)))
{
  proven trivially
}
Inductive step:  ((ztake _v_12 (zip _v_13 (cons _t_14 _t_15)))=(zip (take _v_12 _v_13) (take _v_12 (cons _t_14 _t_15))))
{
  {
    ====================
    | Assumptions [0]: ((nat-to-int zero)=0)
    | Assumptions [1]: (forall ((Nat)) ((nat-to-int _qv_1)>=0))
    | Assumptions [2]: (forall ((Nat) (Nat)) (((nat-to-int _qv_2)=(nat-to-int _qv_3))->(_qv_2=_qv_3)))
    | Assumptions [3]: (forall ((Nat)) ((nat-to-int (succ _qv_4))=(1+(nat-to-int _qv_4))))
    | Assumptions [4]: (forall ((Nat)) ((take _qv_5 nil)=nil))
    | Assumptions [5]: (forall ((Lst)) ((take zero _qv_6)=nil))
    | Assumptions [6]: (forall ((Nat) (Nat) (Lst)) ((take (succ _qv_7) (cons _qv_8 _qv_9))=(cons _qv_8 (take _qv_7 _qv_9))))
    | Assumptions [7]: (forall ((Lst)) ((zip nil _qv_10)=znil))
    | Assumptions [8]: (forall ((Lst)) ((zip _qv_11 nil)=znil))
    | Assumptions [9]: (forall ((Nat) (Lst) (Nat) (Lst)) ((zip (cons _qv_12 _qv_13) (cons _qv_14 _qv_15))=(zcons (mkpair _qv_12 _qv_14) (zip _qv_13 _qv_15))))
    | Assumptions [10]: (forall ((Nat)) ((ztake _qv_16 znil)=znil))
    | Assumptions [11]: (forall ((ZLst)) ((ztake zero _qv_17)=znil))
    | Assumptions [12]: (forall ((Nat) (Pair) (ZLst)) ((ztake (succ _qv_18) (zcons _qv_19 _qv_20))=(zcons _qv_19 (ztake _qv_18 _qv_20))))
    | Assumptions [13]: (forall ((Lst) (Lst)) ((ztake _t_7 (zip xs ys))=(zip (take _t_7 xs) (take _t_7 ys))))
    | Assumptions [14]: (forall ((Lst) (Lst)) ((zip (take _t_7 xs) (take _t_7 ys))=(ztake _t_7 (zip xs ys))))
    | Assumptions [15]: (forall ((Nat) (Lst)) ((ztake n (zip _t_11 ys))=(zip (take n _t_11) (take n ys))))
    | Assumptions [16]: (forall ((Nat) (Lst)) ((zip (take n _t_11) (take n ys))=(ztake n (zip _t_11 ys))))
    | Assumptions [17]: (forall ((Nat) (Lst)) ((ztake n (zip xs _t_15))=(zip (take n xs) (take n _t_15))))
    | Assumptions [18]: (forall ((Nat) (Lst)) ((zip (take n xs) (take n _t_15))=(ztake n (zip xs _t_15))))
    ====================
  }
Unknown
sat
