
The Knowledge Scheme currently contains the following lemmas:
	(forall ((Nat)) ((succ (succ _qv_0))=_qv_0))
	(forall ((Nat)) (0<=(nat-to-int _qv_1)))
	(forall ((Nat) (Nat)) ((plus _qv_2 _qv_3)=(plus _qv_3 _qv_2)))
	(forall ((Nat) (Nat) (Nat)) ((plus (plus _qv_4 _qv_5) _qv_6)=(plus _qv_4 (plus _qv_5 _qv_6))))
	(forall ((Lst) (Lst)) ((append _qv_7 _qv_8)=(append _qv_8 _qv_7)))
	(forall ((Lst) (Lst) (Lst)) ((append (append _qv_9 _qv_10) _qv_11)=(append _qv_9 (append _qv_10 _qv_11))))
	(forall ((Lst)) ((rev (rev _qv_12))=_qv_12))
	(forall ((Lst) (Lst)) ((qreva _qv_13 _qv_14)=(qreva _qv_14 _qv_13)))
	(forall ((Lst) (Lst) (Lst)) ((qreva (qreva _qv_15 _qv_16) _qv_17)=(qreva _qv_15 (qreva _qv_16 _qv_17))))
	(forall ((Nat)) ((nat-to-int (succ _qv_18))=(nat-to-int _qv_18)))
	(forall ((Lst)) ((nat-to-int (len _qv_19))=(nat-to-int _qv_19)))
	(forall ((Lst) (Lst) (Lst)) ((qreva _qv_20 (append _qv_21 _qv_22))=(append (qreva _qv_20 _qv_21) (qreva _qv_20 _qv_22))))
	(forall ((Lst) (Lst) (Lst)) ((append _qv_23 (qreva _qv_24 _qv_25))=(qreva (append _qv_23 _qv_24) (append _qv_23 _qv_25))))
	(forall ((Nat) (Nat)) ((succ (plus _qv_26 _qv_27))=(plus (succ _qv_26) (succ _qv_27))))
	(forall ((Nat) (Nat)) ((succ (plus _qv_26 _qv_27))=(plus (succ _qv_27) (succ _qv_26))))
	(forall ((Lst) (Lst)) ((rev (append _qv_28 _qv_29))=(append (rev _qv_28) (rev _qv_29))))
	(forall ((Lst) (Lst)) ((rev (append _qv_28 _qv_29))=(append (rev _qv_29) (rev _qv_28))))
	(forall ((Lst) (Lst)) ((rev (qreva _qv_30 _qv_31))=(qreva (rev _qv_30) (rev _qv_31))))
	(forall ((Lst) (Lst)) ((rev (qreva _qv_30 _qv_31))=(qreva (rev _qv_31) (rev _qv_30))))

Simplified goal: (forall ((Lst) (Lst)) ((len (qreva x y))=(plus (len x) (len y))))


Base case:       ((len (qreva nil _v_32))=(plus (len nil) (len _v_32)))
{
  proven trivially
}
Inductive step:  ((len (qreva (cons _t_33 _t_34) _v_32))=(plus (len (cons _t_33 _t_34)) (len _v_32)))
{
  proven trivially
}

Proved
unsat
